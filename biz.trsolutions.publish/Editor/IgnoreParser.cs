using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using UnityEngine;

namespace UnityEditor.TRSolutions.Publish {
    public class IgnoreParser
    {
        private static string[] defaultIgnoreList = new string[] {
                "# This .gitignore file should be placed at the root of your Unity project directory",
                "#",
                "# Get latest from https://github.com/github/gitignore/blob/master/Unity.gitignore",
                "#",
                "/[Ll]ibrary/",
                "/[Tt]emp/",
                "/[Oo]bj/",
                "/[Bb]uild/",
                "/[Bb]uilds/",
                "/[Ll]ogs/",
                "/[Mm]emoryCaptures/",
                "/[Rr]ecordings/",
                "",
                "# Never ignore Asset meta data",
                "!/[Aa]ssets/**/*.meta",
                "",
                "# Uncomment this line if you wish to ignore the asset store tools plugin",
                "# /[Aa]ssets/AssetStoreTools*",
                "",
                "# Autogenerated Jetbrains Rider plugin",
                "[Aa]ssets/Plugins/Editor/JetBrains*",
                "",
                "# Visual Studio cache directory",
                ".vs/",
                "",
                "# Gradle cache directory",
                ".gradle/",
                "",
                "# Autogenerated VS/MD/Consulo solution and project files",
                "ExportedObj/",
                ".consulo/",
                "*.csproj",
                "*.unityproj",
                "*.sln",
                "*.suo",
                "*.tmp",
                "*.user",
                "*.userprefs",
                "*.pidb",
                "*.booproj",
                "*.svd",
                "*.pdb",
                "*.mdb",
                "*.opendb",
                "*.VC.db",
                "",
                "# Unity3D generated meta files",
                "*.pidb.meta",
                "*.pdb.meta",
                "*.mdb.meta",
                "",
                "# Unity3D generated file on crash reports",
                "sysinfo.txt",
                "",
                "# Builds",
                "*.apk",
                "*.unitypackage",
                "",
                "# Crashlytics generated file",
                "crashlytics-build.properties"
            };
        private Regex[] keepExpressions;
        private Regex[] ignoreExpressions;

        public IgnoreParser() : this(IgnoreParser.defaultIgnoreList)
        {

        }

        public IgnoreParser(string[] ignoreList)
        {
            // If we can find a ".gitignore" in the current folder,
            // use it. Otherwise stick to our default
            if (File.Exists(".gitignore"))
            {
                ignoreList = File.ReadAllLines(".gitignore");
            }
        
            var keepExpressionList = new List<Regex>(ignoreList.Length);
            var ignoreExpressionList = new List<Regex>(ignoreList.Length);
            // construct the list of expressions from our input data
            foreach (var line in ignoreList)
            {
                // skip comments
                if (line.Length == 0 || line.StartsWith("#")) {
                    continue;
                }
                // Keep or ignore?
                bool keep;
                string processLine;
                if (line.StartsWith("!"))
                {
                    keep = true;
                    processLine = line.Substring(1);
                } else
                {
                    keep = false;
                    processLine = line;
                }
                // Convert to regex string
                var expression = PrepareRegex(processLine);
                if (keep)
                {
                    keepExpressionList.Add(new Regex(expression));
                } else
                {
                    ignoreExpressionList.Add(new Regex(expression));
                }
            }
            keepExpressions = keepExpressionList.ToArray();
            ignoreExpressions = ignoreExpressionList.ToArray();
        }

        public bool IsIgnored(string path)
        {
            foreach (var expression in keepExpressions)
            {
                if (expression.IsMatch(path))
                {
                    return false;
                }
            }
            foreach (var expression in ignoreExpressions)
            {
                if (expression.IsMatch(path))
                {
                    return true;
                }
            }
            return false;
        }

        public override string ToString()
        {
            var output = "keep: ";
            for (int i = 0; i < (keepExpressions.Length - 1); i++)
            {
                output += keepExpressions[i] + "\n      ";
            }
            if (keepExpressions.Length > 0)
            {
                output += keepExpressions[keepExpressions.Length - 1];
            }

            output += "\nignore: ";
            for (int i = 0; i < (ignoreExpressions.Length - 1); i++)
            {
                output += ignoreExpressions[i] + "\n      ";
            }
            if (ignoreExpressions.Length > 0)
            {
                output += ignoreExpressions[ignoreExpressions.Length - 1];
            }

            return output;
        }

        // -------------------------------------------------

        private string PrepareRegex(string line)
        {
            // . -> [.]
            // ** -> (.+)
            // * -> [^/]+
            // return escapeRegex(pattern).replace('**', '(.+)').replace('*', '([^\\/]+)');
            return EscapeRegex(line)
                .Replace(@"\/**\/", "(.+)") // "A slash followed by two conseq asterisks then a slash matches 0 or more directories."
                .Replace("**", "(.+)")
                .Replace("*", "([^\\/]+)");
        }
        private string EscapeRegex(string pattern)
        {
            // Escape the following special characters:
            // -, [, ], /, {, }, (, ), +, ?, ., \, ^, $, |
            // return pattern.replace(/[\-\[\]\/\{\}\(\)\+\?\.\\\^\$\|]/ g, "\\$&");
            var findPattern = new Regex(@"[\-\/\{\}\(\)\+\?\.\\\^\$\|]");
            return findPattern.Replace(pattern, "\\$&");
        }

    }
}
